<!DOCTYPE html>
<html>

  <head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Uber准备 - Less Or More</title>

	<link rel="shortcut icon" href="/myProject/styles/images/favicon.jpg">
	<link rel="icon" href="/myProject/styles/images/favicon.jpg">

	<link rel="stylesheet" href="/myProject/styles/css/index.css">
	<link rel="stylesheet" href="/myProject/styles/css/fontawesome/css/font-awesome.min.css">
	<link rel="stylesheet" href="/myProject/styles/css/syntax.css">
	<link rel="canonical" href="/myProject/2019/01/01/Uber%E5%87%86%E5%A4%87/">
	<link rel="alternate" type="application/rss+xml" title="Less Or More" href="/myProject/feed.xml">
	
	<meta name="keywords" content="Uber准备, Less Or More, 康志华;个人博客;非淡泊无以明志, 非宁静无以致远 ;思而不学则殆;生命不止;折腾不休">
	<meta name="description" content="康志华;个人博客;非淡泊无以明志, 非宁静无以致远 ;思而不学则殆;生命不止;折腾不休">

	<script src="/myProject/styles/js/jquery.min.js"></script>
	<!--[if lt IE 9]>
    	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  	<![endif]-->
  	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?94be4b0f9fc5d94cc0d0415ea6761ae9";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
  	<style type="text/css">
	  	.docs-content{
	  		margin-bottom: 10px;
	  	}
  	</style>
</head>

  <body class="index">

    <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <!-- <a href="/" class="navbar-brand">
        <img src="/myProject/styles/images/logo.jpg">
      </a> -->
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">    
        <li>
          <a href="/myProject/">SATOSHI在硅谷</a>
        </li>
        <li>
          <a href="/myProject/categories/">大类分解</a>
        </li>
        <li>
          <a href="/myProject/tag">小类内聚</a>
        </li>
        <li>
          <a href="/myProject/categories/">地产</a>
        </li>
        <li>
          <a href="/myProject/tag">股票</a>
        </li>
        <li>
          <a href="/myProject/tag">比特币以及加密货币</a>
        </li>
        <li>
          <a href="/myProject/tag">旅游美食</a>
        </li>
        <li>
          <a href="/myProject/tag">LEETCODE 刷题</a>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <!-- <li>
            <a><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></a>
        </li> -->
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">关于<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/">Github</a></li>
            <li><a rel="nofollow" target="_blank" href="http://www.hifreud.com/Resume.io/">关于作者</a></li>
            <li><a rel="nofollow" href="/myProject/books">我的书单</a></li>
            <!-- <li><a rel="nofollow" href="http://www.hifreud.com/domains/">域名管理</a></li> -->
            <!-- <li><a rel="nofollow" href="/myProject/reference">推荐博客</a></li> -->
            <li><a href="/myProject/feed.xml">RSS订阅</a></li>
            <!-- <li class="divider"></li>
            <li><a rel="nofollow" target="_blank" href="https://github.com/luoyan35714/LessOrMore.git">本项目</a></li> -->
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>

    <div class="container docs-container">
  <div class="row">
    <div class="col-md-2">
      <div class="sidebar hidden-print" role="complementary">
        <div id="navigation">
  <h1>目录</h1>
  <ul class="nav sidenav">
  </ul>
  <!-- <div style="height: 200px;width: 200px;">
    <script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"> 
    </script>
  </div> -->
</div>


      </div>
    </div>
    <div class="col-md-10" role="main">
      <div class="panel docs-content">
        <div class="wrapper">
            <header class="post-header">
              <h1 class="post-title">Uber准备</h1>
              <!--
                <p class="post-meta">Jan 1, 2019</p>
              -->
              <div class="meta">Posted on <span class="postdate">Jan 01, 2019</span> By <a target="_blank" href="http://localhost:4000">Luan Zhang</a></div>
              <br />
            </header>
            <article class="post-content">
              <ul>
  <li>content</li>
</ul>

<li>Min Stack</li>
<li>Leetcode 230. Kth Smallest Element in a BST</li>
<li>Permutation I &amp;&amp; Permutation II</li>
<li>Course Schedule I, II</li>
<li>LeetCode287. Find Duplicate Number</li>
<li>Leetcode 99. Recover Binary Search Tree</li>
<li>Leetcide 652. Find Duplicate Subtrees</li>
<li><a>LeetCode215. Kth Largest Element in an Array </a></li>

<p>之前解决这道题的时候, 是创建2个stack, 然后无脑的往stack里面push元素, 在这里，不妨去思考一下什么时候需要push, 什么时候不需要push, 创建一个stack2里面是最小的元素, 只有当新进来的元素，比stack2的栈顶元素要小的时候，才需要把元素给push进去</p>

<p>什么时候需要pop stack2呢 就是 stack2的top元素和stack1的元素进行比较，如果他们相同的话, 就需要把该元素给pop出去</p>

<li>Leetcode 230. Kth Smallest Element in a BST</li>
<p>在BST里面找到第K个大小的元素, 这样的题目可以用递归的做法, 可以用非递归的做法, 非递归的做法就是 非递归的去中序inorder遍历一棵树， 非递归的inorder的做法值得注意的就是每次往stack里面去push元素的时候, 都是在第二个while循环里面, 在第一个循环的结尾处, 改变root的指向</p>

<h3>Leetcode516: Longest Palindromic Subsequence</h3>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">longestPalindromeSubseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="s">"""
        :type s: str
        :rtype: int
        """</span>
        <span class="k">def</span> <span class="nf">lps</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> 

            <span class="c1"># Base Case 1: If there is  
</span>            <span class="c1"># only 1 character  
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">):</span> 
                <span class="k">return</span> <span class="mi">1</span>

            <span class="c1"># Base Case 2: If there are only 2  
</span>            <span class="c1"># characters and both are same  
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">j</span><span class="p">):</span> 
                <span class="k">return</span> <span class="mi">2</span>

            <span class="c1"># If the first and last characters match  
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">seq</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span> 
                <span class="k">return</span> <span class="n">lps</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

            <span class="c1"># If the first and last characters 
</span>            <span class="c1"># do not match  
</span>            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lps</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>  
                       <span class="n">lps</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">lps</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lps</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span> 
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> 
  
    <span class="c1"># Create a table to store results of subproblems 
</span>    <span class="n">L</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> 
  
    <span class="c1"># Strings of length 1 are palindrome of length 1 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> 
        <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  
    <span class="c1"># Build the table. Note that the lower  
</span>    <span class="c1"># diagonal values of table are 
</span>    <span class="c1"># useless and not filled in the process.  
</span>    <span class="c1"># The values are filled in a 
</span>    <span class="c1"># manner similar to Matrix Chain  
</span>    <span class="c1"># Multiplication DP solution (See 
</span>    <span class="c1"># https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/ 
</span>    <span class="c1"># cl is length of substring 
</span>    <span class="k">for</span> <span class="n">cl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">cl</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> 
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">cl</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">cl</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> 
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="nb">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span> 
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span> 
  
    <span class="k">return</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> </code></pre></figure>

<h3>Course Schedule I II</h3>

<p>Course Schedule的本质就是有向图中找环的问题 图中找环可以用2种方法来做，</p>

<p>第一种方法就是用dfs, 但是对于图中的每一个点，需要对应三种状态, 

这里我就想了一下，为什么对于2种状态的visited就不行呢, 因为是有向图, 举一个例子吧，就是对于下图, 刚开始从1开始遍历，1 指向2, 再指向3, 节点2，3 will be marked as visited point, however, then we start trave from node 4, when travel to node 4's neighbor, it has been reached to 3, 3 has been visited, but we could not say that this graph has cycle,

1 -&gt; 2 -&gt; 3 &lt;- 4      

所以呢，我们就需要三种状态去标记, 我们无妨将这三种状态设为 -1, 0, 1, 初始的状态我们可以设为0, 如果在一条路径访问的时候，此时此刻的node设为-1, 当我们在遍历的过程当中发现了 此时此刻visted[i] = -1 我们就可以说，这个图中会有环, 当我们访问过之后，可以将改个节点标志为1， 下次进入dfs的函数中之后, 如果visited[i] == 1, just return true

1 -&gt; 2 -&gt; 3 &lt;- 4

同样是这个例子, 让我们来走一个，刚开始的时候，是从图中的1开始遍历, 遍历node1的邻居2, 之后遍历node2的邻居 3，3没有邻居，所以我们的dfs函数开始返回, 直到返回到最上层，此时此刻node1, node2, node3 都被标记状态为1的节点了, 再从4开始遍历，遍历到node 3, node 3的状态为1, 所以返回, 此时此刻，我们就知道</p>

<p>还有一种方法就是拓扑排序, 拓扑排序的原理就是bfs,找到入度为0的节点, 在把其邻居节点的入度减去1</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">):</span>
        <span class="s">"""
        :type numCourses: int
        :type prerequisites: List[List[int]]
        :rtype: bool
        """</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">indegree</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="n">indegree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">prerequisite</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">prerequisite</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prerequisite</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">indegree</span><span class="p">[</span><span class="n">prerequisite</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># print graph
</span>        <span class="c1"># print indegree
</span>        <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indegree</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>   
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">cur_course</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">cur_course</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">nei</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">cur_course</span><span class="p">]:</span>
                        <span class="n">indegree</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nei</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="n">numCourses</span></code></pre></figure>

<p>做完这道题之后, 我想做一下其他关于拓扑排序的其他题目,巩固一下, So I picked up 787. leetcode787: Cheapest Flights Within K Stops, 这道题就是用拓扑排序找一下最短路径, 但是如何保存cost, 如何每次取最小的那个cost,  具体的思路如下</p>

<ol>
  <li>queue里面入的是 (node, src) 还需要一个result代表总的cost, 当dst等于src的时候,
return min(result, neiCost)，你想着是return min(result, cost), 但是事实情况不是这样的，事实情况是如下图，从1开始遍历, 目标是到node 2</li>
</ol>

<p>从1开始遍历的时候, 直接遍历到2，此时此刻result是400，直接return的话, 答案就不对了，所以还是要return 300的, 这里只是保存了一个result. 只有到最后的时候才去return 这个result</p>

<p>另外一个值得注意的地方就是, 如何去判断cost, cost + nei &lt; result 的时候</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">   <span class="mi">200</span>     <span class="mi">400</span>  
<span class="mi">3</span><span class="o">&lt;-----</span><span class="mi">1</span> <span class="o">------&gt;</span> <span class="mi">2</span>
<span class="o">|</span>                <span class="o">*</span>              
<span class="o">|</span><span class="n">_____100________</span><span class="o">|</span></code></pre></figure>

<h3>Leetcode287: find Duplicate number</h3>
<p>题目描述: 就是总共有n + 1个 Integer, 这 n + 1 个 整数里面有 1 到 n 个整数</p>

<p>这道题用hashmap做太简单了,时间复杂度, 空间复杂度都是O(n), 有没有什么办法可以不用O(n)的空间, 其实也很简单, 因为有n + 1个数, 而且数组里面的数都是介于 0 到 n 之间的, 所以可以将都是正数的数变成负数, 这样的话, 一旦发现数组里面的某一个index对应的数是负数的话,就说明这个数为duplicate的数</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python">    <span class="k">def</span> <span class="nf">findDuplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="s">"""
        :type nums: List[int]
        :rtype: int
        """</span>
        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">temp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span></code></pre></figure>

<h3>Leetcode 652. Find Duplicate Subtrees</h3>

<p>这道题出的非常好啊, 题目的大致意思就是给一个binary tree 要从其中找出来duplicate subtree的节点</p>

<ol>
  <li>
    <p>首先如何去判断是substree是duplicate的,很自然的就想到了, 需要用hashmap，但是hashmap的key是什么, 如果保证key唯一，举个例子，如下图, 他们是不同的substree,</p>
  </li>
  <li>
    <p>如果node为空的话, 直接返回空的的string,就会导致下面2个例子是一模一样的subtree, 明显和题目的意思不符合</p>
  </li>
  <li>
    <p>如何将重复的node加进去呢, 我觉得判断dic[path] == 1的时候,加进去node特别巧妙, 这样的话, 就可以知道node是啥了</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-python" data-lang="python">   <span class="mi">0</span>             <span class="mi">0</span>
    \         <span class="o">/</span>
     <span class="mi">0</span>         <span class="mi">0</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">findDuplicateSubtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="s">"""
        :type root: TreeNode
        :rtype: List[TreeNode]
        """</span>
        
        <span class="n">dic</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            
            <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s">'#'</span>
            
            <span class="n">rootStr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">rootStr</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rootStr</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">rootStr</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dic</span><span class="p">[</span><span class="n">rootStr</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">rootStr</span> <span class="o">+</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
        
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span></code></pre></figure>

<h3>LeetCode215. Kth Largest Element in an Array &lt;/a&gt;</h3>

<h3>Meeting Room II</h3>

<p>这道题用minHeap来做, 时间复杂度是O(n *logn), 对于heap来说的话, heap push 和heap pop的时间复杂度都是 logn的时间复杂度</p>

<ol>
  <li>第一种情况就是，新来的interval 的start是大于 min end的, 说明min end所在的那个interval 是可以可以被pop出去, 在新的interval里面push进去新的end</li>
</ol>


            </article>
        </div>
      </div>
    </div>
  </div>
</div>


    <footer class="footer" role="contentinfo">
	<div class="container">
		<p class="copyright">Copyright &copy; 2014-2020 <a href="http://www.hifreud.com/Resume.io/"><code>Luan Zhang</code></a>.</p>
		<p>Powered by <a href="http://jekyllrb.com">Jekyll</a>, themed from <a href="http://lesscss.cn/">Less</a>, refactored by <a href="http://www.hifreud.com/">Freud Kang</a></p>
	</div>
</footer>

<script src="/myProject/styles/js/jquery.min.js"></script>
<script src="/myProject/styles/js/bootstrap.min.js"></script>
<script src="/myProject/styles/js/holder.min.js"></script>
<script src="/myProject/styles/js/lessismore.js"></script>
<script src="/myProject/styles/js/application.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  </body>
</html>
