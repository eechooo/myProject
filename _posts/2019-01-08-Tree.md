---
layout: post
title: Tree 专题
date:   2019-01-07 01:00:00 +0800
categories: document
tag: 教程
---

<li>Smallest Subtree with all the Deepest Nodes</li>


<h3>Smallest Subtree with all the Deepest Nodes</h3>

这道题是的意思是找出树中所有deepest node的父亲节点, 刚开始的思路是

比较左子树和右子树的高度，如果他们的高度相同的话, 直接return node， 如果高度不相同的话，继续去左子树和右子树高度比较高的subtree里面去寻找, 如果这样的话, 最好的情况是左右子树高度一样, 这样的话就直接return root, 这样的话时间复杂度, 就是O(n),最坏的情况是
节点全部在左边, 或者全部在右边, 这样的话时间复杂度就是O(n*n)

下面的算法, 时间复杂度就是O(n), 具体的思路如下,

1. 求出每一层的深度(这边与其他不同的是,是求深度，而不是高度), 注意这里root节点的深度是0, 节点的深度比较深, 

2. 之后，我们有个function, 这个function 每次传入一个node, 判断这个node的深度, using divide and conquer, 求左边L 还有 右边 R, 如果L 和 R都不为空的话, 说明当前的node就是 root. 

这样的话, 每个节点都仅仅遍历了一遍, 时间复杂度是O(n)


{% highlight python %}
class Solution(object):
    def subtreeWithAllDeepest(self, root):
        # Tag each node with it's depth.
        depth = {None: -1}
        def dfs(node, parent = None):
            if node:
                depth[node] = depth[parent] + 1
                dfs(node.left, node)
                dfs(node.right, node)
        dfs(root)
        max_depth = max(depth.itervalues())
        def answer(node):
            # Return the answer for the subtree at node.
            if not node or depth.get(node, None) == max_depth:
                return node
            L, R = answer(node.left), answer(node.right)
            return node if L and R else L or R
        return answer(root)
{% endhighlight %}

